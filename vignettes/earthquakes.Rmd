---
title: "earthquakes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{earthquakes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

```{r setup}
library(earthquakes)
library(leaflet)
```

This repository contains an R package for visualizing data from the [NCEI/WDS Global Significant Earthquake Database](https://www.ngdc.noaa.gov/hazel/view/hazards/earthquake/search). The functions provided with this package fall into 3 general categories: reading/cleaning data, creating ggplot2 layers, and generating leaflet maps. This vignette briefly explains how to use each function defined in this package. 

# Reading and Cleaning Data

The function `eq_read_data` has one optional argument `filename` which should be a string with the path to a file containing tab-delimited data downloaded from the [NCEI/WDS Global Significant Earthquake Database](https://www.ngdc.noaa.gov/hazel/view/hazards/earthquake/search). By default, it uses the path to data included with the package, it reads in the file to a dataframe and formats the column names:

```{r read_data}
# Read in the data
data <- eq_read_data() 

# View the last 5 rows
data %>%
  dplyr::select(YEAR, MONTH, DAY, LOCATION, LONGITUDE, LATITUDE, MAG, TOTAL_DEATHS) %>%
  utils::tail()
```

The function `eq_location_clean` has one optional argument `data` which should a dataframe outputted by `eq_read_data`. If no argument is given, `eq_read_data` is called internally. This functions splits the `LOCATION` column which is usually of the format "COUNTRY: REGION" (e.g. "JAPAN:TOKYO") into separate columns `COUNTRY` and `REGION`

```{r, location_clean}
# Pass previous data to eq_location_clean
data <- data %>% 
  eq_location_clean() 

# View the last 5 rows
data %>%
  dplyr::select(YEAR, MONTH, DAY, COUNTRY, REGION, LONGITUDE, LATITUDE, MAG, TOTAL_DEATHS) %>%
  utils::tail()
```

The function `eq_clean_data` has one optional argument `data` which should be a dataframe outputted by `eq_location_clean`. If no argument is given, `eq_location_clean` is called internally. This function creates a `DATE` column using values from the `HOUR`, `MINUTE` and `SECONDS` columns and functions from the lubridate package.

```{r clean_data}
# Pass previous data to eq_clean_data
data <- data %>%
  eq_clean_data()

# View the last 5 rows
data %>%
  dplyr::select(DATE, COUNTRY, REGION, LONGITUDE, LATITUDE, MAG, TOTAL_DEATHS) %>%
  utils::tail()
```

Note, we can get the same output by simply using `eq_clean_data` without passing it any arguments:

```{r clean_data1}
# Generate same dataset as before
data <- eq_clean_data()

# View the last 5 rows
data %>%
  dplyr::select(DATE, YEAR, COUNTRY, REGION, LONGITUDE, LATITUDE, MAG, TOTAL_DEATHS) %>%
  utils::tail()
```

For the remaining examples we will subset our data to include only a few relevant columns and observations:

```{r subset}
data <- data %>% 
    dplyr::filter(!is.na(TOTAL_DEATHS)) %>% 
    dplyr::select(DATE, YEAR, COUNTRY, REGION, LONGITUDE, LATITUDE, MAG, TOTAL_DEATHS) %>%
  tidyr::drop_na()
```

# Timelines

The function `geom_timeline` can be used to add layers to ggplot which draw a timeline. The only required aesthetic is `x` which determines where along the timeline circles will be placed. The optional aesthetic `y` determines the other timelines to be displayed, the optional aesthetics `size`,`color`,`alpha` determine the size, color and transparency of the circles drawn along the timeline.

```{r, timeline, eval = FALSE}
# Subset data to only earthquakes in three countries after the year 2000.
data %>% dplyr::filter(YEAR > 1999,
                       COUNTRY %in% c("JAPAN", "CHINA","NEPAL")) %>%
    ggplot2::ggplot(aes(x = DATE,
                      y = COUNTRY,
                      size = MAG,
                      color = TOTAL_DEATHS)) +
    geom_timeline()
```

```{r timeline1, echo=FALSE, out.width = '100%'}
knitr::include_graphics(file.path("..","man","figures","README-timeline-1.png"))
```

The function `geom_timeline_label` can be used to add layers to ggplot which draw labels with markers (line segments), this is intended to be used with the timelines generated by `geom_timeline`. The required aesthetics are `x` which determines where along the timeline the markers will be placed, `label` which determines what the labels will be and `mag` which indicates a column by which the observations are ranked to determine which get labeled. The optional aesthetic `y`, allows for stratification vertically, the optional aesthetics `color` and `alpha` detemine the color and transparant of the line segments and the optional aesthetic `n_max` determines how many observations we label. By default `n_max = 3`:

```{r, timelinelabel, eval = FALSE}
data %>% dplyr::filter(COUNTRY == "JAPAN", 
                              YEAR >= 1900) %>%
  ggplot2::ggplot(aes(x = DATE,
                      y = COUNTRY,
                      size = MAG,
                      color = TOTAL_DEATHS,
                      label = REGION,
                      mag = MAG)) +
  geom_timeline() +
  geom_timeline_label(aes(n_max = 5))
```

```{r timelinelabel1, echo=FALSE, out.width = '100%'}
knitr::include_graphics(file.path("..","man","figures","README-timelinelabel-1.png"))
```

# Leaflet Maps

The function `eq_map` uses the `leaflet` package to generate maps, it takes one argument `annot_col` indicating a column to be used for annotation (by default `annot_col = DATE`). Given a dataframe with columns `LONGITUDE`, `LATITUDE`, `MAG`, and `annot_col` the function eq_map places a circle at each coordinate. When hovered over, a pop-up text with the contents of `annot_col` are displayed.

```{r, basicmap, eval = FALSE}
data %>% 
  dplyr::filter(COUNTRY == "MEXICO", 
                YEAR >= 2000) %>% 
  eq_map(annot_col = "DATE")
```

```{r basicmap1, echo=FALSE, out.width = '100%'}
knitr::include_graphics(file.path("..","man","figures","eq_map.png"))
```

The function `eq_create_label` can be use in conjunction with `eq_map` to generate fancier labels using HTML. A typical usage is within a call to `dplyr::mutate` to generate a column containing the pop-up text which will be used as `annot_col` when the output is passed to `eq_map`. Requires that the given dataframe has columns `REGION`, `TOTAL_DEATHS`, and `MAG`.

```{r, fancymap, eval = FALSE}
data %>% 
  dplyr::filter(COUNTRY == "MEXICO",
                YEAR >= 2000) %>% 
  dplyr::mutate(popup_text = eq_create_label(.)) %>% 
  eq_map(annot_col = "popup_text")
```

```{r fancymap1, echo=FALSE, out.width = '100%'}
knitr::include_graphics(file.path("..","man","figures","eq_create_label.png"))
```
